<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

  <title>
    
      Dialogue 1 - Comparing models &middot; Supplementary material
    
  </title>

  


  <!-- CSS -->
  <link rel="stylesheet" href="/socialpsychtutorial/assets/css/main.css" />
  

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface" />

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/socialpsychtutorial/favicon.png" />
<link rel="shortcut icon" href="/socialpsychtutorial/favicon.ico" />

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml" />

  <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

</head>


  <body class="index">

    <div id="sidebar">
  <header>
    <h1 class="site-title">
      <a href="/socialpsychtutorial/">
        
          <span class="back-arrow icon"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0h24v24H0z" fill="none"/>
  <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
</svg></span>
        
        Supplementary material
      </a>
    </h1>
    <p class="lead">Formalising verbal theories: A tutorial by dialogue</p>
  </header>
  <nav id="sidebar-nav-links">
  
  

  

  


  

  

  

  
    
      <a class="page-link "
          href="/socialpsychtutorial/">Welcome</a>
    
  

  
    
      <a class="page-link "
          href="/socialpsychtutorial/chapter2/">Math concepts and notation</a>
    
  

  
    
  

  
    
      <a class="page-link "
          href="/socialpsychtutorial/dialogue1/">Dialogue 1 - Individual models</a>
    
  

  
    
      <a class="page-link  active"
          href="/socialpsychtutorial/dialogue1_comparison/">Dialogue 1 - Comparing models</a>
    
  


  


  

  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  


  <!-- Optional additional links to insert in sidebar nav -->
</nav>


  

  <nav id="sidebar-icon-links">
  

  <a id="subscribe-link"
     class="icon" title="Subscribe" aria-label="Subscribe"
     href="/socialpsychtutorial/feed.xml">
    <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <circle cx="6.18" cy="17.82" r="2.18"/>
    <path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"/>
</svg>
  </a>

  
  
  
  

  

  

  <!-- Optional additional links to insert for icons links -->
</nav>

  &#169; 2020, Mark Blokpoel and Iris van Rooij. This material has been released under a CC-BY 4.0 license and a GNU GPL v3 license. 

</div>

    <main class="container">
      <div class="content">
  


  <div id="toc-wrapper">
<ul id="markdown-toc">
  <li><a href="#comparing-model-behavior-by-hand" id="markdown-toc-comparing-model-behavior-by-hand">Comparing model behavior by hand</a></li>
  <li><a href="#comparing-model-behaviour-large-scale" id="markdown-toc-comparing-model-behaviour-large-scale">Comparing model behaviour large scale</a></li>
</ul>

</div>

<p>We take two approaches to analyze differences in model behavior. First, we
explore model behavior by hand. Second, we explore it by large scale simulation.</p>

<h1 id="comparing-model-behavior-by-hand">Comparing model behavior by hand</h1>
<p>If you were already comparing the three models on the previous page, you
may have noticed differences in behavior. If not, you can use the following
code box to try different groups and see what selection of invitees each
model makes.</p>

<div data-scalafiddle="" data-template="PersonsWithFormalisations">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">val</span> <span class="o">(</span><span class="n">p1</span><span class="o">,</span> <span class="n">p2</span><span class="o">,</span> <span class="n">p3</span><span class="o">,</span> <span class="n">p4</span><span class="o">,</span> <span class="n">p5</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="nc">Person</span><span class="o">(</span><span class="s">"p1"</span><span class="o">),</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"p2"</span><span class="o">),</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"p3"</span><span class="o">),</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"p4"</span><span class="o">),</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"p5"</span><span class="o">))</span>

<span class="k">val</span> <span class="nv">P</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="n">p1</span><span class="o">,</span> <span class="n">p2</span><span class="o">,</span> <span class="n">p3</span><span class="o">,</span> <span class="n">p4</span><span class="o">,</span> <span class="n">p5</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">L</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="n">p1</span><span class="o">,</span> <span class="n">p2</span><span class="o">,</span> <span class="n">p3</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">D</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="n">p4</span><span class="o">,</span> <span class="n">p5</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">relations</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span>
  <span class="n">p1</span> <span class="n">like</span> <span class="n">p2</span><span class="o">,</span>
  <span class="n">p1</span> <span class="n">like</span> <span class="n">p3</span><span class="o">,</span>
  <span class="n">p2</span> <span class="n">like</span> <span class="n">p3</span><span class="o">,</span>
  <span class="n">p3</span> <span class="n">like</span> <span class="n">p4</span><span class="o">,</span>
  <span class="n">p1</span> <span class="n">like</span> <span class="n">p5</span><span class="o">,</span>
  <span class="n">p2</span> <span class="n">like</span> <span class="n">p5</span>
<span class="o">)</span>
<span class="k">def</span> <span class="nf">like</span> <span class="k">=</span> <span class="nv">relations</span><span class="o">.</span><span class="py">deriveFun</span>
<span class="k">val</span> <span class="nv">k</span> <span class="k">=</span> <span class="mi">3</span>

<span class="k">val</span> <span class="nv">out4</span> <span class="k">=</span> <span class="nf">si4</span><span class="o">(</span><span class="n">P</span><span class="o">,</span> <span class="n">L</span><span class="o">,</span> <span class="n">D</span><span class="o">,</span> <span class="n">like</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">out5</span> <span class="k">=</span> <span class="nf">si5</span><span class="o">(</span><span class="n">P</span><span class="o">,</span> <span class="n">L</span><span class="o">,</span> <span class="n">D</span><span class="o">,</span> <span class="n">like</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">out6</span> <span class="k">=</span> <span class="nf">si6</span><span class="o">(</span><span class="n">P</span><span class="o">,</span> <span class="n">L</span><span class="o">,</span> <span class="n">D</span><span class="o">,</span> <span class="n">like</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span>

<span class="nf">println</span><span class="o">(</span><span class="nf">h2</span><span class="o">(</span><span class="s">"Input:"</span><span class="o">))</span>
<span class="nv">VegaRenderer</span><span class="o">.</span><span class="py">render</span><span class="o">(</span><span class="nv">relations</span><span class="o">.</span><span class="py">deriveGraph</span><span class="o">(</span><span class="n">P</span><span class="o">))</span>
<span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"k=$k (when applicable)"</span><span class="o">)</span>

<span class="nf">println</span><span class="o">(</span><span class="nf">h2</span><span class="o">(</span><span class="s">"Output:"</span><span class="o">))</span>
<span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"SI4 selects: $out4"</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"SI5 selects: $out5"</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"SI6 selects: $out6"</span><span class="o">)</span>
</code></pre></div></div>
</div>

<h1 id="comparing-model-behaviour-large-scale">Comparing model behaviour large scale</h1>

<p>In the simulation experiment below, we randomly create groups of people and
their relationships to each other and the host. We can do this <code class="highlighter-rouge">sampleSize</code>
times. For each group of friends generated, we ask three agents (hosts
corresponding to the three models SI4, SI5 and SI6) to select invitees,
resulting in three (possibly different) outputs.</p>

<p>We then perform some data analysis by computing a property of the input,
viz. the ratio of likes and dislikes; and by computing two example dependent
variables:</p>

<ol>
  <li>The average number of pairs that like each other amongst invitees; and</li>
  <li>The number of invited guests.</li>
</ol>

<p>Try to play around with the parameters <code class="highlighter-rouge">groupSize</code> and <code class="highlighter-rouge">sampleSize</code>
and see what changes. For example, increasing the number of samples, decreases
the variation in the data.</p>

<div data-scalafiddle="" data-template="PersonsWithFormalisations">
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">groupSize</span> <span class="k">=</span> <span class="mi">5</span>
<span class="k">val</span> <span class="nv">sampleSize</span> <span class="k">=</span> <span class="mi">50</span>

<span class="k">val</span> <span class="nv">P</span> <span class="k">=</span> <span class="nv">List</span><span class="o">.</span><span class="py">tabulate</span><span class="o">(</span><span class="n">groupSize</span><span class="o">)(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="nv">Person</span><span class="o">.</span><span class="py">random</span><span class="o">).</span><span class="py">toSet</span>

<span class="k">val</span> <span class="nv">results</span> <span class="k">=</span> <span class="nf">for</span><span class="o">(</span><span class="n">trialNr</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">sampleSize</span><span class="o">)</span> <span class="k">yield</span> <span class="o">{</span>
  <span class="c1">// Generate random relationships with the host</span>
  <span class="k">val</span> <span class="nv">ld</span> <span class="k">=</span> <span class="nv">P</span><span class="o">.</span><span class="py">toList</span><span class="o">.</span><span class="py">splitAt</span><span class="o">(</span><span class="nv">Random</span><span class="o">.</span><span class="py">nextInt</span><span class="o">(</span><span class="nv">P</span><span class="o">.</span><span class="py">size</span><span class="o">))</span>
  <span class="k">val</span> <span class="nv">L</span> <span class="k">=</span> <span class="nv">ld</span><span class="o">.</span><span class="py">_1</span><span class="o">.</span><span class="py">toSet</span>
  <span class="k">val</span> <span class="nv">D</span> <span class="k">=</span> <span class="nv">ld</span><span class="o">.</span><span class="py">_2</span><span class="o">.</span><span class="py">toSet</span>
  <span class="c1">// Generate random relations between pairs of people</span>
  <span class="k">val</span> <span class="nv">relations</span> <span class="k">=</span> <span class="nv">P</span><span class="o">.</span><span class="py">uniquepairs</span>
    <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">pair</span> <span class="k">=&gt;</span> <span class="nf">if</span><span class="o">(</span><span class="nv">Random</span><span class="o">.</span><span class="py">nextBoolean</span><span class="o">)</span> <span class="nv">pair</span><span class="o">.</span><span class="py">_1</span> <span class="n">like</span> <span class="nv">pair</span><span class="o">.</span><span class="py">_2</span> <span class="k">else</span> <span class="nv">pair</span><span class="o">.</span><span class="py">_1</span> <span class="n">dislike</span> <span class="nv">pair</span><span class="o">.</span><span class="py">_2</span><span class="o">)</span>

  <span class="c1">// Three agents select invitees</span>
  <span class="k">val</span> <span class="nv">outputSI4</span> <span class="k">=</span> <span class="nf">si4</span><span class="o">(</span><span class="n">P</span><span class="o">,</span> <span class="n">L</span><span class="o">,</span> <span class="n">D</span><span class="o">,</span> <span class="nv">relations</span><span class="o">.</span><span class="py">deriveFun</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
  <span class="k">val</span> <span class="nv">outputSI5</span> <span class="k">=</span> <span class="nf">si5</span><span class="o">(</span><span class="n">P</span><span class="o">,</span> <span class="n">L</span><span class="o">,</span> <span class="n">D</span><span class="o">,</span> <span class="nv">relations</span><span class="o">.</span><span class="py">deriveFun</span><span class="o">)</span>
  <span class="k">val</span> <span class="nv">outputSI6</span> <span class="k">=</span> <span class="nf">si6</span><span class="o">(</span><span class="n">P</span><span class="o">,</span> <span class="n">L</span><span class="o">,</span> <span class="n">D</span><span class="o">,</span> <span class="nv">relations</span><span class="o">.</span><span class="py">deriveFun</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>

  <span class="c1">// Compute independent variables</span>
  <span class="k">val</span> <span class="nv">nrLikes</span> <span class="k">=</span> <span class="nv">relations</span><span class="o">.</span><span class="py">count</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">liking</span><span class="o">)</span>
  <span class="k">val</span> <span class="nv">nrDislikes</span> <span class="k">=</span> <span class="nv">relations</span><span class="o">.</span><span class="py">count</span><span class="o">(!</span><span class="nv">_</span><span class="o">.</span><span class="py">liking</span><span class="o">)</span>
  <span class="k">val</span> <span class="nv">ldRatio</span> <span class="k">=</span> <span class="nv">nrLikes</span><span class="o">.</span><span class="py">toDouble</span> <span class="o">/</span> <span class="n">nrDislikes</span>

  <span class="c1">// Compute dependend variables</span>
  <span class="k">val</span> <span class="nv">partySize4</span> <span class="k">=</span> <span class="nv">outputSI4</span><span class="o">.</span><span class="py">size</span>
  <span class="k">val</span> <span class="nv">partySize5</span> <span class="k">=</span> <span class="nv">outputSI5</span><span class="o">.</span><span class="py">size</span>
  <span class="k">val</span> <span class="nv">partySize6</span> <span class="k">=</span> <span class="nv">outputSI6</span><span class="o">.</span><span class="py">size</span>

  <span class="k">val</span> <span class="nv">like4</span> <span class="k">=</span> <span class="nf">for</span><span class="o">(</span><span class="n">g1</span> <span class="k">&lt;-</span> <span class="nv">outputSI4</span><span class="o">.</span><span class="py">toList</span><span class="o">)</span> <span class="nf">yield</span>
      <span class="o">(</span><span class="nf">for</span><span class="o">(</span><span class="n">g2</span> <span class="k">&lt;-</span> <span class="nv">outputSI4</span><span class="o">.</span><span class="py">toList</span> <span class="nf">if</span><span class="o">(</span><span class="n">g1</span><span class="o">!=</span><span class="n">g2</span><span class="o">))</span> <span class="k">yield</span> <span class="nv">relations</span><span class="o">.</span><span class="py">contains</span><span class="o">(</span><span class="n">g1</span> <span class="n">like</span> <span class="n">g2</span><span class="o">)).</span><span class="py">count</span><span class="o">(</span><span class="k">_</span> <span class="o">==</span> <span class="kc">true</span><span class="o">)</span>  
  <span class="k">val</span> <span class="nv">like5</span> <span class="k">=</span> <span class="nf">for</span><span class="o">(</span><span class="n">g1</span> <span class="k">&lt;-</span> <span class="nv">outputSI5</span><span class="o">.</span><span class="py">toList</span><span class="o">)</span> <span class="nf">yield</span>
      <span class="o">(</span><span class="nf">for</span><span class="o">(</span><span class="n">g2</span> <span class="k">&lt;-</span> <span class="nv">outputSI5</span><span class="o">.</span><span class="py">toList</span> <span class="nf">if</span><span class="o">(</span><span class="n">g1</span><span class="o">!=</span><span class="n">g2</span><span class="o">))</span> <span class="k">yield</span> <span class="nv">relations</span><span class="o">.</span><span class="py">contains</span><span class="o">(</span><span class="n">g1</span> <span class="n">like</span> <span class="n">g2</span><span class="o">)).</span><span class="py">count</span><span class="o">(</span><span class="k">_</span> <span class="o">==</span> <span class="kc">true</span><span class="o">)</span>
  <span class="k">val</span> <span class="nv">like6</span> <span class="k">=</span> <span class="nf">for</span><span class="o">(</span><span class="n">g1</span> <span class="k">&lt;-</span> <span class="nv">outputSI6</span><span class="o">.</span><span class="py">toList</span><span class="o">)</span> <span class="nf">yield</span>
      <span class="o">(</span><span class="nf">for</span><span class="o">(</span><span class="n">g2</span> <span class="k">&lt;-</span> <span class="nv">outputSI6</span><span class="o">.</span><span class="py">toList</span> <span class="nf">if</span><span class="o">(</span><span class="n">g1</span><span class="o">!=</span><span class="n">g2</span><span class="o">))</span> <span class="k">yield</span> <span class="nv">relations</span><span class="o">.</span><span class="py">contains</span><span class="o">(</span><span class="n">g1</span> <span class="n">like</span> <span class="n">g2</span><span class="o">)).</span><span class="py">count</span><span class="o">(</span><span class="k">_</span> <span class="o">==</span> <span class="kc">true</span><span class="o">)</span>

  <span class="k">val</span> <span class="nv">avgLike4</span> <span class="k">=</span> <span class="nv">like4</span><span class="o">.</span><span class="py">sum</span><span class="o">.</span><span class="py">toDouble</span> <span class="o">/</span> <span class="nv">like4</span><span class="o">.</span><span class="py">length</span>
  <span class="k">val</span> <span class="nv">avgLike5</span> <span class="k">=</span> <span class="nv">like5</span><span class="o">.</span><span class="py">sum</span><span class="o">.</span><span class="py">toDouble</span> <span class="o">/</span> <span class="nv">like5</span><span class="o">.</span><span class="py">length</span>
  <span class="k">val</span> <span class="nv">avgLike6</span> <span class="k">=</span> <span class="nv">like6</span><span class="o">.</span><span class="py">sum</span><span class="o">.</span><span class="py">toDouble</span> <span class="o">/</span> <span class="nv">like6</span><span class="o">.</span><span class="py">length</span>

  <span class="c1">// Return the dataset for this random graph</span>
  <span class="o">(</span><span class="nc">Map</span><span class="o">(</span><span class="s">"likes"</span> <span class="o">-&gt;</span> <span class="n">nrLikes</span><span class="o">,</span> <span class="s">"dislikes"</span> <span class="o">-&gt;</span> <span class="n">nrDislikes</span><span class="o">,</span> <span class="s">"ldRatio"</span> <span class="o">-&gt;</span> <span class="n">ldRatio</span><span class="o">,</span> <span class="s">"avgLike"</span> <span class="o">-&gt;</span> <span class="n">avgLike4</span><span class="o">,</span> <span class="s">"partySize"</span> <span class="o">-&gt;</span> <span class="n">partySize4</span><span class="o">),</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"likes"</span> <span class="o">-&gt;</span> <span class="n">nrLikes</span><span class="o">,</span> <span class="s">"dislikes"</span> <span class="o">-&gt;</span> <span class="n">nrDislikes</span><span class="o">,</span> <span class="s">"ldRatio"</span> <span class="o">-&gt;</span> <span class="n">ldRatio</span><span class="o">,</span> <span class="s">"avgLike"</span> <span class="o">-&gt;</span> <span class="n">avgLike5</span><span class="o">,</span> <span class="s">"partySize"</span> <span class="o">-&gt;</span> <span class="n">partySize5</span><span class="o">),</span>
  <span class="nc">Map</span><span class="o">(</span><span class="s">"likes"</span> <span class="o">-&gt;</span> <span class="n">nrLikes</span><span class="o">,</span> <span class="s">"dislikes"</span> <span class="o">-&gt;</span> <span class="n">nrDislikes</span><span class="o">,</span> <span class="s">"ldRatio"</span> <span class="o">-&gt;</span> <span class="n">ldRatio</span><span class="o">,</span> <span class="s">"avgLike"</span> <span class="o">-&gt;</span> <span class="n">avgLike6</span><span class="o">,</span> <span class="s">"partySize"</span> <span class="o">-&gt;</span> <span class="n">partySize6</span><span class="o">))</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">si4Data</span> <span class="k">=</span> <span class="nv">results</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">_1</span><span class="o">).</span><span class="py">toList</span>
<span class="k">val</span> <span class="nv">si5Data</span> <span class="k">=</span> <span class="nv">results</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">_2</span><span class="o">).</span><span class="py">toList</span>
<span class="k">val</span> <span class="nv">si6Data</span> <span class="k">=</span> <span class="nv">results</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">_3</span><span class="o">).</span><span class="py">toList</span>

<span class="nf">render</span><span class="o">(</span><span class="n">traces</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Trace</span><span class="o">(</span><span class="s">"SI4"</span><span class="o">,</span> <span class="n">si4Data</span><span class="o">),</span> <span class="nc">Trace</span><span class="o">(</span><span class="s">"SI5"</span><span class="o">,</span> <span class="n">si5Data</span><span class="o">),</span> <span class="nc">Trace</span><span class="o">(</span><span class="s">"SI6"</span><span class="o">,</span> <span class="n">si6Data</span><span class="o">)),</span>
      <span class="n">xValue</span> <span class="k">=</span> <span class="s">"ldRatio"</span><span class="o">,</span>
      <span class="n">xLabel</span> <span class="k">=</span> <span class="s">"Likes / dislikes ratio in P"</span><span class="o">,</span>
      <span class="n">yValue</span> <span class="k">=</span> <span class="s">"avgLike"</span><span class="o">,</span>
      <span class="n">yLabel</span> <span class="k">=</span> <span class="s">"Average likes amongst invitees"</span><span class="o">,</span>
      <span class="n">title</span> <span class="k">=</span> <span class="s">"Like/Dislike ratios"</span><span class="o">,</span>
      <span class="n">plotType</span> <span class="k">=</span> <span class="nv">PlotType</span><span class="o">.</span><span class="py">Point</span><span class="o">)</span>

<span class="nf">render</span><span class="o">(</span><span class="n">traces</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Trace</span><span class="o">(</span><span class="s">"SI4"</span><span class="o">,</span> <span class="n">si4Data</span><span class="o">),</span> <span class="nc">Trace</span><span class="o">(</span><span class="s">"SI5"</span><span class="o">,</span> <span class="n">si5Data</span><span class="o">),</span> <span class="nc">Trace</span><span class="o">(</span><span class="s">"SI6"</span><span class="o">,</span> <span class="n">si6Data</span><span class="o">)),</span>
      <span class="n">xValue</span> <span class="k">=</span> <span class="s">"ldRatio"</span><span class="o">,</span>
      <span class="n">xLabel</span> <span class="k">=</span> <span class="s">"Likes / dislikes ratio in P"</span><span class="o">,</span>
      <span class="n">yValue</span> <span class="k">=</span> <span class="s">"partySize"</span><span class="o">,</span>
      <span class="n">yLabel</span> <span class="k">=</span> <span class="s">"Number of invitees"</span><span class="o">,</span>
      <span class="n">title</span> <span class="k">=</span> <span class="s">"Party size"</span><span class="o">,</span>
      <span class="n">plotType</span> <span class="k">=</span> <span class="nv">PlotType</span><span class="o">.</span><span class="py">Point</span><span class="o">)</span>

</code></pre></div></div>
</div>



  

  

</div>
    </main>

    <!-- Optional footer content -->

  
<script>
  window.scalaFiddleTemplates = {

    'PersonsWithFormalisations': {
      pre: 'import scala.util.Random\nimport scalatags.JsDom.all._\n\n/**\n  * This renderer allows the user to render a Vega plot specification. The specifying\n  * must be passed as a String and will be rendered in a div.\n  */\ncase object VegaRenderer {\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Point = Value\n  }\n\n  case class Trace(label: String, data: List[Map[String, Any]]) {\n    def toVegaString: String = data.map(convertValues(label, _)).mkString(", ")\n  }\n\n  case class Graph(nodes: List[Any], edges: List[(Any, Any, String)]) {\n    private def toVegaData: (Trace, Trace) = {\n      val nDat: List[Map[String, Any]] = (nodes zip nodes.indices).map(ni => Map("lab" -> ni._1.toString, "id" -> ni._2, "maxId" -> nodes.length))\n      val nodesTrace = Trace("node", nDat)\n      val eDat: List[Map[String, Any]] = edges.map(e => Map("id1" -> nodes.indexOf(e._1), "id2" -> nodes.indexOf(e._2), "lab" -> e._3, "maxId" -> nodes.length))\n      val edgesTrace = Trace("edge", eDat)\n      (nodesTrace, edgesTrace)\n    }\n\n    def toVegaString: String = toVegaData._1.toVegaString + ",\\n" + toVegaData._2.toVegaString\n  }\n\n  def convertValues(label: String, values: Map[String, Any]): String =\n    values.toSeq.map(v => {\n      if(v._2.isInstanceOf[String])\n        s""""${v._1}": "${v._2}""""\n      else\n        s""""${v._1}": ${v._2}"""\n    }).\n    mkString(s"""{"label": "$label",""",",","}")\n\n  import PlotType._\n\n  var plotCounter = 0\n\n  def render(vegaSpec: String): Unit = {\n    Fiddle.print(\n      div(id:=s"plot$plotCounter", s"Rendering plot $plotCounter..."),\n      script(s"""\n        var script = document.createElement(\'script\');\n        script.onload = function () {\n          requirejs.config({\n            baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n            paths: {\n              "vega-embed":  "vega-embed@6?noext",\n              "vega-lib": "vega-lib?noext",\n              "vega-lite": "vega-lite@4?noext",\n              "vega": "vega@5?noext"\n            }\n          });\n\n        require(["vega-embed"], function(vegaEmbed) {\n          const spec = {\n            $vegaSpec\n          };\n          vegaEmbed(\'#plot$plotCounter\', spec, {defaultStyle: true, renderer: "svg"}).catch(console.warn);\n        });\n      };\n\n      script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n      document.head.appendChild(script);\n      """)\n    )\n    plotCounter = plotCounter + 1\n  }\n\n  def render(graph: Graph): Unit = render(genGraphSpec(graph))\n\n  def render(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line): Unit =\n      render(\n        genSpec(\n          traces,\n          xValue,\n          xLabel,\n          yValue,\n          yLabel,\n          title,\n          plotType\n        )\n      )\n\n  def genSpec(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line): String = {\n      s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "title": "$title",\n      "data": { "values": [\n          ${traces.map(_.toVegaString).mkString(",\\n")}\n      ]},\n      """ + {\n        if(plotType==PlotType.Bar && traces.length==1) {\n          s"""\n          "width": 300,\n          "mark": "bar",\n          "encoding": {\n            "x": {"field": "$xValue", "type": "ordinal", "title": "$xLabel"},\n            "y": {"field": "$yValue", "type": "quantitative", "title": "$yLabel"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": {"orient": "bottom", "title": null}\n            }\n          }\n          """\n        } else if(plotType==PlotType.Bar && traces.length>1) {\n          s"""\n          "width": 10,\n          "mark": "bar",\n          "encoding": {\n            "column": {\n              "field": "$xValue", "type": "nominal", "spacing": 0\n            },\n            "x": {"field": "label", "type": "ordinal", "axis": {"title": ""}},\n            "y": {"field": "$yValue", "type": "quantitative", "title": "$yLabel"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": null\n            }\n          }\n          """\n        } else if(plotType==PlotType.Line || plotType==PlotType.Point) {\n          s"""\n          "width": 300,\n          "encoding": {\n              "x": {\n                "field": "$xValue",\n                "type": "ordinal",\n                "axis": {"format": ".2f", "titlePadding": 30},\n                "title": "$xLabel"\n              },\n              "color": {\n                "field": "label",\n                "type": "nominal",\n                "legend": {"orient": "bottom", "title": null}\n              }\n          },\n          "layer": [\n            {\n              "mark": "errorbar",\n              "encoding": {\n                "y": {"field": "$yValue", "type": "quantitative", "title": "$yLabel"}\n              }\n            },\n            {\n              "mark": "${plotType.toString.toLowerCase}",\n              "encoding": {\n                "y": {\n                  "field": "$yValue",\n                  "aggregate": "mean",\n                  "type": "quantitative",\n                  "axis": {"format": ".2f", "titlePadding": 30},\n                  "title": "$yLabel"\n                }\n              }\n            }\n          ]\n          """\n        }\n      }\n  }.replace(" ","").replace("\\n","")\n\n  def genGraphSpec(graph: Graph): String = {\n    s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "width": 300,\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "data": {\n        "values": [\n              ${graph.toVegaString}\n            ]\n      },\n      "layer": [\n            {\n            "transform": [\n                  {"filter": "datum.label == \'edge\'"},\n                  {"calculate": "sin(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                  {"calculate": "cos(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                  {"calculate": "sin(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "x2"},\n                  {"calculate": "cos(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "y2"}\n                ],\n            "mark": {\n                "type": "rule",\n                "size": 3\n            },\n            "encoding": {\n                "x": {"field": "x", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "y": {"field": "y", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "x2": {"field": "x2", "type": "quantitative"},\n                "y2": {"field": "y2", "type": "quantitative"},\n                "color": {\n                  "field": "lab",\n                  "type": "nominal",\n                  "scale": {"scheme": "set1"},\n                  "legend": {"orient": "bottom", "title": null}\n                }\n            }\n          },\n          {\n            "transform": [\n                {"filter": "datum.label == \'node\'"},\n                {"calculate": "sin(datum.id / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                {"calculate": "1.2*sin(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dx"},\n                {"calculate": "cos(datum.id / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                {"calculate": "1.2*cos(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dy"}\n            ],\n            "layer": [\n                {\n                    "encoding": {\n                        "x": {"field": "x", "type": "quantitative", "axis": null},\n                        "y": {"field": "y", "type": "quantitative", "axis": null}\n                    },\n                    "mark": {\n                        "type": "circle",\n                        "opacity": 1,\n                        "size": 200\n                    }\n                },\n                {\n                    "mark": {\n                        "type": "text",\n                        "baseline": "middle"\n                    },\n                    "encoding": {\n                        "x": {"field": "dx", "type": "quantitative", "axis": null},\n                        "y": {"field": "dy", "type": "quantitative", "axis": null},\n                        "text": {"field": "lab", "type": "nominal"}\n                    }\n                }\n            ]\n          }\n      ]\n    """\n  }\n}\n\n/**\n  * Implementation of basic set theory as implicits\n  */\n  object Math {\n    implicit class ImplSet[A](set: Set[A]) {\n      // for set membership, use set.contains(element)\n\n      def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n\n      def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n\n      def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n\n      def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n\n      // for intersection use set.intersection(set2)\n\n      // for union use set.union(set2)\n\n      // for difference use set.diff(set2)\n\n      def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n      def diff(set2: Set[A]): Set[A] = (set diff set2) union (set2 diff set)\n\n      def cardinalProduct[B](set2: Set[B]): Set[(A,B)] =\n        for(x <- set; y <- set2) yield (x,y)\n\n      def cardinalProduct[B](set2: Set[B], condition: (A, B) => Boolean): Set[(A,B)] =\n        for(x <- set; y <- set2 if condition(x,y)) yield (x,y)\n\n      def pairs: Set[(A,A)] = for(x <- set; y <- set) yield (x,y)\n\n      def uniquepairs: Set[(A,A)] = for(x <- set; y <- set if x!=y) yield (x,y)\n\n      def powerset: Set[Set[A]] = set.subsets.toSet\n\n      def argMax(f: A => Double): Option[A] = {\n        val seq = set.toSeq // convert to sequence to preserve ordering in zip function\n        val valSeq = seq map f\n        val maxValue = valSeq.max\n        val maxValSet = seq zip valSeq filter (_._2 == maxValue)\n        if(maxValSet.nonEmpty) Some(maxValSet(new Random().nextInt(maxValSet.length))._1) // if one or more maxima exist return random\n        else None\n      }\n\n      def argMaxOrElse(f: A => Double)(fallback: A): A = {\n        val seq = set.toSeq // convert to sequence to preserve ordering in zip function\n        val valSeq = seq map f\n        val maxValue = valSeq.max\n        val maxValSet = seq zip valSeq filter (_._2 == maxValue)\n        if(maxValSet.nonEmpty) maxValSet(new Random().nextInt(maxValSet.length))._1 // if one or more maxima exist return random\n        else fallback\n      }\n\n      def random: A = set.toList(Random.nextInt(set.size))\n    }\n\n    implicit class Impl2Set[A,B](sets: Tuple2[Set[A],Set[B]]) {\n      // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n      def build(f: (A, B) => Boolean): Set[(A,B)] =\n        (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    }\n\n    implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n      def bigUnion: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n      def bigIntersection: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n    }\n\n    def requirement(b: Boolean, msg: String): Unit =\n      if(!b) {\n        println(s"Requirement not met: $msg")\n        assert(false)\n      }\n  }\n\nimport Math._\nimport VegaRenderer._\n\n\ncase class Person(name: String) {\n  def like(other: Person): Relation = Relation(this, other, true)\n  def dislike(other: Person): Relation = Relation(this, other, false)\n\n  override def toString: String = name\n}\n\ncase object Person {\n    val names = List("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n    def random: Person = Person(names(Random.nextInt(names.length)))\n    def randomGroup(size: Int): Set[Person] = List.tabulate(size)(_ => Person.random).toSet\n}\n\ncase class Relation(a: Person, b: Person, liking: Boolean) {\n    def canEqual(a: Any) = a.isInstanceOf[Relation]\n\n    override def equals(that: Any): Boolean = that match {\n        case that: Relation => {\n            this.liking == that.liking && (this.a == that.a && this.b == that.b || this.a == that.b && this.b == that.a)\n        }\n        case _ => false\n    }\n}\n\nobject Helpers {\n  import Math._\n\n  implicit class ImplRelation(personA: String) {\n    def likes(personB: String): Relation = Relation(Person(personA), Person(personB), true)\n\n    def dislikes(personB: String): Relation = Relation(Person(personA), Person(personB), false)\n  }\n\n  implicit class ImplRelFun(relations: Set[Relation]) {\n    def deriveFun: ((Person, Person) => Boolean) = {\n      (a: Person, b: Person) => {\n        val rel = relations.find(p => p.a == a && p.b == b || p.a == b && p.b == a)\n        if(rel.isDefined) rel.get.liking\n        else false\n      }\n    }\n\n    def deriveGraph(persons: Set[Person]): Graph = {\n      val edges = for(p1 <- persons; p2 <- persons if p1 != p2) yield {\n        val col = if(deriveFun(p1, p2)) "likes" else "dislikes"\n        (p1, p2, col)\n      }\n      Graph(persons.toList, edges.toList)\n    }\n  }\n}\n\nimport Math._\nimport Helpers._\n\ndef si4(P: Set[Person],\n        L: Set[Person],\n        D: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n  requirement(L subsetOf P, "L must be a subset of P")\n  requirement(D subsetOf P, "D must be a subset of P")\n  requirement((L intersect D).isEmpty, "intersection between L and D must be emtpy")\n  requirement((L union D) == P, "union of L and D must equal P")\n\n  P.subsets.toSet // G \\subseteq P\n   .filter(G => (G intersect D).size <= k) // such that |G \\cap D| <= k\n   .argMax(G => G.size + G.uniquepairs.build(Function.tupled(like)).size)\n   .get\n}\n\ndef si5(P: Set[Person],\n        L: Set[Person],\n        D: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n  requirement(L subsetOf P, "l must be a subset of p")\n  requirement(D subsetOf P, "d must be a subset of p")\n  requirement((L intersect D).isEmpty, "intersection between l and d must be emtpy")\n  requirement((L union D) == P, "union of l and d must equal p")\n\n\n  P.subsets.toSet // G \\subseteq P\n   .argMax(G => {\n     (G intersect L).size // |G \\cap L|\n     + G.size // |G|\n     + G.uniquepairs.build(pair => like(pair._1, pair._2)).size // |X|\n   })\n   .get\n}\n\ndef si6(P: Set[Person],\n        L: Set[Person],\n        D: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n    requirement(L subsetOf P, "l must be a subset of p")\n    requirement(D subsetOf P, "d must be a subset of p")\n    requirement((L intersect D).isEmpty, "intersection between l and d must be emtpy")\n    requirement((L union D) == P, "union of l and d must equal p")\n\n\n  P.subsets.toSet // G \\subseteq P\n   .filter(G => G.uniquepairs.build(pair => !like(pair._1, pair._2)).size <= k)\n   .argMax(G => (G intersect L).size + G.size)\n   .get\n}\n\n',
      post: ''
    }
,

    'PersonsWithFormalisations': {
      pre: 'import scala.util.Random\nimport scalatags.JsDom.all._\n\n/**\n  * This renderer allows the user to render a Vega plot specification. The specifying\n  * must be passed as a String and will be rendered in a div.\n  */\ncase object VegaRenderer {\n  case object PlotType extends Enumeration {\n    type PlotType = Value\n    val Line, Bar, Point = Value\n  }\n\n  case class Trace(label: String, data: List[Map[String, Any]]) {\n    def toVegaString: String = data.map(convertValues(label, _)).mkString(", ")\n  }\n\n  case class Graph(nodes: List[Any], edges: List[(Any, Any, String)]) {\n    private def toVegaData: (Trace, Trace) = {\n      val nDat: List[Map[String, Any]] = (nodes zip nodes.indices).map(ni => Map("lab" -> ni._1.toString, "id" -> ni._2, "maxId" -> nodes.length))\n      val nodesTrace = Trace("node", nDat)\n      val eDat: List[Map[String, Any]] = edges.map(e => Map("id1" -> nodes.indexOf(e._1), "id2" -> nodes.indexOf(e._2), "lab" -> e._3, "maxId" -> nodes.length))\n      val edgesTrace = Trace("edge", eDat)\n      (nodesTrace, edgesTrace)\n    }\n\n    def toVegaString: String = toVegaData._1.toVegaString + ",\\n" + toVegaData._2.toVegaString\n  }\n\n  def convertValues(label: String, values: Map[String, Any]): String =\n    values.toSeq.map(v => {\n      if(v._2.isInstanceOf[String])\n        s""""${v._1}": "${v._2}""""\n      else\n        s""""${v._1}": ${v._2}"""\n    }).\n    mkString(s"""{"label": "$label",""",",","}")\n\n  import PlotType._\n\n  var plotCounter = 0\n\n  def render(vegaSpec: String): Unit = {\n    Fiddle.print(\n      div(id:=s"plot$plotCounter", s"Rendering plot $plotCounter..."),\n      script(s"""\n        var script = document.createElement(\'script\');\n        script.onload = function () {\n          requirejs.config({\n            baseUrl: \'https://cdn.jsdelivr.net/npm/\',\n            paths: {\n              "vega-embed":  "vega-embed@6?noext",\n              "vega-lib": "vega-lib?noext",\n              "vega-lite": "vega-lite@4?noext",\n              "vega": "vega@5?noext"\n            }\n          });\n\n        require(["vega-embed"], function(vegaEmbed) {\n          const spec = {\n            $vegaSpec\n          };\n          vegaEmbed(\'#plot$plotCounter\', spec, {defaultStyle: true, renderer: "svg"}).catch(console.warn);\n        });\n      };\n\n      script.src = "https://requirejs.org/docs/release/2.3.6/minified/require.js";\n      document.head.appendChild(script);\n      """)\n    )\n    plotCounter = plotCounter + 1\n  }\n\n  def render(graph: Graph): Unit = render(genGraphSpec(graph))\n\n  def render(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line): Unit =\n      render(\n        genSpec(\n          traces,\n          xValue,\n          xLabel,\n          yValue,\n          yLabel,\n          title,\n          plotType\n        )\n      )\n\n  def genSpec(traces: List[Trace],\n    xValue: String,\n    xLabel: String,\n    yValue: String,\n    yLabel: String,\n    title: String,\n    plotType: PlotType = PlotType.Line): String = {\n      s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "title": "$title",\n      "data": { "values": [\n          ${traces.map(_.toVegaString).mkString(",\\n")}\n      ]},\n      """ + {\n        if(plotType==PlotType.Bar && traces.length==1) {\n          s"""\n          "width": 300,\n          "mark": "bar",\n          "encoding": {\n            "x": {"field": "$xValue", "type": "ordinal", "title": "$xLabel"},\n            "y": {"field": "$yValue", "type": "quantitative", "title": "$yLabel"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": {"orient": "bottom", "title": null}\n            }\n          }\n          """\n        } else if(plotType==PlotType.Bar && traces.length>1) {\n          s"""\n          "width": 10,\n          "mark": "bar",\n          "encoding": {\n            "column": {\n              "field": "$xValue", "type": "nominal", "spacing": 0\n            },\n            "x": {"field": "label", "type": "ordinal", "axis": {"title": ""}},\n            "y": {"field": "$yValue", "type": "quantitative", "title": "$yLabel"},\n            "color": {\n              "field": "label",\n              "type": "nominal",\n              "legend": null\n            }\n          }\n          """\n        } else if(plotType==PlotType.Line || plotType==PlotType.Point) {\n          s"""\n          "width": 300,\n          "encoding": {\n              "x": {\n                "field": "$xValue",\n                "type": "ordinal",\n                "axis": {"format": ".2f", "titlePadding": 30},\n                "title": "$xLabel"\n              },\n              "color": {\n                "field": "label",\n                "type": "nominal",\n                "legend": {"orient": "bottom", "title": null}\n              }\n          },\n          "layer": [\n            {\n              "mark": "errorbar",\n              "encoding": {\n                "y": {"field": "$yValue", "type": "quantitative", "title": "$yLabel"}\n              }\n            },\n            {\n              "mark": "${plotType.toString.toLowerCase}",\n              "encoding": {\n                "y": {\n                  "field": "$yValue",\n                  "aggregate": "mean",\n                  "type": "quantitative",\n                  "axis": {"format": ".2f", "titlePadding": 30},\n                  "title": "$yLabel"\n                }\n              }\n            }\n          ]\n          """\n        }\n      }\n  }.replace(" ","").replace("\\n","")\n\n  def genGraphSpec(graph: Graph): String = {\n    s"""\n      "$$schema": "https://vega.github.io/schema/vega-lite/v4.json",\n      "width": 300,\n      "height": 340,\n      "autosize": {\n        "type": "fit",\n        "contains": "padding"\n      },\n      "data": {\n        "values": [\n              ${graph.toVegaString}\n            ]\n      },\n      "layer": [\n            {\n            "transform": [\n                  {"filter": "datum.label == \'edge\'"},\n                  {"calculate": "sin(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                  {"calculate": "cos(datum.id1 / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                  {"calculate": "sin(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "x2"},\n                  {"calculate": "cos(datum.id2 / datum.maxId * 2 * PI)+1.5", "as": "y2"}\n                ],\n            "mark": {\n                "type": "rule",\n                "size": 3\n            },\n            "encoding": {\n                "x": {"field": "x", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "y": {"field": "y", "type": "quantitative", "axis": null, "scale": {"domain": [0, 3]}},\n                "x2": {"field": "x2", "type": "quantitative"},\n                "y2": {"field": "y2", "type": "quantitative"},\n                "color": {\n                  "field": "lab",\n                  "type": "nominal",\n                  "scale": {"scheme": "set1"},\n                  "legend": {"orient": "bottom", "title": null}\n                }\n            }\n          },\n          {\n            "transform": [\n                {"filter": "datum.label == \'node\'"},\n                {"calculate": "sin(datum.id / datum.maxId * 2 * PI)+1.5", "as": "x"},\n                {"calculate": "1.2*sin(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dx"},\n                {"calculate": "cos(datum.id / datum.maxId * 2 * PI)+1.5", "as": "y"},\n                {"calculate": "1.2*cos(datum.id / datum.maxId * 2 * PI + 0.1)+1.5", "as": "dy"}\n            ],\n            "layer": [\n                {\n                    "encoding": {\n                        "x": {"field": "x", "type": "quantitative", "axis": null},\n                        "y": {"field": "y", "type": "quantitative", "axis": null}\n                    },\n                    "mark": {\n                        "type": "circle",\n                        "opacity": 1,\n                        "size": 200\n                    }\n                },\n                {\n                    "mark": {\n                        "type": "text",\n                        "baseline": "middle"\n                    },\n                    "encoding": {\n                        "x": {"field": "dx", "type": "quantitative", "axis": null},\n                        "y": {"field": "dy", "type": "quantitative", "axis": null},\n                        "text": {"field": "lab", "type": "nominal"}\n                    }\n                }\n            ]\n          }\n      ]\n    """\n  }\n}\n\n/**\n  * Implementation of basic set theory as implicits\n  */\n  object Math {\n    implicit class ImplSet[A](set: Set[A]) {\n      // for set membership, use set.contains(element)\n\n      def isSubsetOf(set2: Set[A]): Boolean = set != set2 && set.subsetOf(set2)\n\n      def isSubsetEqTo(set2: Set[A]): Boolean = set.subsetOf(set2)\n\n      def isSupersetOf(set2: Set[A]): Boolean = set2 isSubsetOf set\n\n      def isSupersetEqTo(set2: Set[A]): Boolean = set2 isSubsetEqTo set\n\n      // for intersection use set.intersection(set2)\n\n      // for union use set.union(set2)\n\n      // for difference use set.diff(set2)\n\n      def build(f: A => Boolean): Set[A] = set.filter(f(_))\n\n      def diff(set2: Set[A]): Set[A] = (set diff set2) union (set2 diff set)\n\n      def cardinalProduct[B](set2: Set[B]): Set[(A,B)] =\n        for(x <- set; y <- set2) yield (x,y)\n\n      def cardinalProduct[B](set2: Set[B], condition: (A, B) => Boolean): Set[(A,B)] =\n        for(x <- set; y <- set2 if condition(x,y)) yield (x,y)\n\n      def pairs: Set[(A,A)] = for(x <- set; y <- set) yield (x,y)\n\n      def uniquepairs: Set[(A,A)] = for(x <- set; y <- set if x!=y) yield (x,y)\n\n      def powerset: Set[Set[A]] = set.subsets.toSet\n\n      def argMax(f: A => Double): Option[A] = {\n        val seq = set.toSeq // convert to sequence to preserve ordering in zip function\n        val valSeq = seq map f\n        val maxValue = valSeq.max\n        val maxValSet = seq zip valSeq filter (_._2 == maxValue)\n        if(maxValSet.nonEmpty) Some(maxValSet(new Random().nextInt(maxValSet.length))._1) // if one or more maxima exist return random\n        else None\n      }\n\n      def argMaxOrElse(f: A => Double)(fallback: A): A = {\n        val seq = set.toSeq // convert to sequence to preserve ordering in zip function\n        val valSeq = seq map f\n        val maxValue = valSeq.max\n        val maxValSet = seq zip valSeq filter (_._2 == maxValue)\n        if(maxValSet.nonEmpty) maxValSet(new Random().nextInt(maxValSet.length))._1 // if one or more maxima exist return random\n        else fallback\n      }\n\n      def random: A = set.toList(Random.nextInt(set.size))\n    }\n\n    implicit class Impl2Set[A,B](sets: Tuple2[Set[A],Set[B]]) {\n      // Example (set, set2) build((a: Int, b: Int) => a/2==0 && b%2==0)\n      def build(f: (A, B) => Boolean): Set[(A,B)] =\n        (sets._1 cardinalProduct sets._2) build Function.tupled(f)\n    }\n\n    implicit class ImplSetSet[A](setOfSets: Set[Set[A]]) {\n      def bigUnion: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ union _) else Set.empty\n\n      def bigIntersection: Set[A] =\n        if(setOfSets.nonEmpty) setOfSets.reduce(_ intersect _) else Set.empty\n    }\n\n    def requirement(b: Boolean, msg: String): Unit =\n      if(!b) {\n        println(s"Requirement not met: $msg")\n        assert(false)\n      }\n  }\n\nimport Math._\nimport VegaRenderer._\n\n\ncase class Person(name: String) {\n  def like(other: Person): Relation = Relation(this, other, true)\n  def dislike(other: Person): Relation = Relation(this, other, false)\n\n  override def toString: String = name\n}\n\ncase object Person {\n    val names = List("Nettie","Lester","Brian","Cody","Erik","William","Molly","Joey","Thelma","Edgar","Emanuel","Sergio","Herman","Kelley","Wilfred","Guadalupe","Paula","Sheila","Javier","Kelly","Jason","Gilbert","Harriet","Meghan","Kenneth","Holly","Rose","Lela","Brenda","Constance","Vera","Ramiro","Diana","Charlene","Betty","Michelle","Frederick","Elmer","Byron","Randal","Roderick","Clark","Mathew","Sammy","Colleen","Marian","Tyrone","Keith","Tonya","John","Kayla","Johanna","Dwayne","Antonia","Kerry","Fannie","Nichole","Jeanne","Roberto","Vicky","Jesus","Angela","Fredrick","Fernando","Vivian","Natalie","Johnnie","Monica","Angelica","Anna","Carlos","Marion","Henry","Lawrence","Alexis","Garry","Bernard","Jana","Ernestine","Deborah","Willard","Eileen","Erica","Elvira","Myron","Elena","Ervin","Jeannette","Veronica","Abraham","Lamar","Wanda","Lorraine","Doris","Leigh","Devin","Lindsay","Isabel","Marlene","Betsy")\n    def random: Person = Person(names(Random.nextInt(names.length)))\n    def randomGroup(size: Int): Set[Person] = List.tabulate(size)(_ => Person.random).toSet\n}\n\ncase class Relation(a: Person, b: Person, liking: Boolean) {\n    def canEqual(a: Any) = a.isInstanceOf[Relation]\n\n    override def equals(that: Any): Boolean = that match {\n        case that: Relation => {\n            this.liking == that.liking && (this.a == that.a && this.b == that.b || this.a == that.b && this.b == that.a)\n        }\n        case _ => false\n    }\n}\n\nobject Helpers {\n  import Math._\n\n  implicit class ImplRelation(personA: String) {\n    def likes(personB: String): Relation = Relation(Person(personA), Person(personB), true)\n\n    def dislikes(personB: String): Relation = Relation(Person(personA), Person(personB), false)\n  }\n\n  implicit class ImplRelFun(relations: Set[Relation]) {\n    def deriveFun: ((Person, Person) => Boolean) = {\n      (a: Person, b: Person) => {\n        val rel = relations.find(p => p.a == a && p.b == b || p.a == b && p.b == a)\n        if(rel.isDefined) rel.get.liking\n        else false\n      }\n    }\n\n    def deriveGraph(persons: Set[Person]): Graph = {\n      val edges = for(p1 <- persons; p2 <- persons if p1 != p2) yield {\n        val col = if(deriveFun(p1, p2)) "likes" else "dislikes"\n        (p1, p2, col)\n      }\n      Graph(persons.toList, edges.toList)\n    }\n  }\n}\n\nimport Math._\nimport Helpers._\n\ndef si4(P: Set[Person],\n        L: Set[Person],\n        D: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n  requirement(L subsetOf P, "L must be a subset of P")\n  requirement(D subsetOf P, "D must be a subset of P")\n  requirement((L intersect D).isEmpty, "intersection between L and D must be emtpy")\n  requirement((L union D) == P, "union of L and D must equal P")\n\n  P.subsets.toSet // G \\subseteq P\n   .filter(G => (G intersect D).size <= k) // such that |G \\cap D| <= k\n   .argMax(G => G.size + G.uniquepairs.build(Function.tupled(like)).size)\n   .get\n}\n\ndef si5(P: Set[Person],\n        L: Set[Person],\n        D: Set[Person],\n        like: (Person, Person) => Boolean): Set[Person] = {\n  requirement(L subsetOf P, "l must be a subset of p")\n  requirement(D subsetOf P, "d must be a subset of p")\n  requirement((L intersect D).isEmpty, "intersection between l and d must be emtpy")\n  requirement((L union D) == P, "union of l and d must equal p")\n\n\n  P.subsets.toSet // G \\subseteq P\n   .argMax(G => {\n     (G intersect L).size // |G \\cap L|\n     + G.size // |G|\n     + G.uniquepairs.build(pair => like(pair._1, pair._2)).size // |X|\n   })\n   .get\n}\n\ndef si6(P: Set[Person],\n        L: Set[Person],\n        D: Set[Person],\n        like: (Person, Person) => Boolean,\n        k: Int): Set[Person] = {\n    requirement(L subsetOf P, "l must be a subset of p")\n    requirement(D subsetOf P, "d must be a subset of p")\n    requirement((L intersect D).isEmpty, "intersection between l and d must be emtpy")\n    requirement((L union D) == P, "union of l and d must equal p")\n\n\n  P.subsets.toSet // G \\subseteq P\n   .filter(G => G.uniquepairs.build(pair => !like(pair._1, pair._2)).size <= k)\n   .argMax(G => (G intersect L).size + G.size)\n   .get\n}\n\n',
      post: ''
    }

  }
</script>

<script defer src='https://embed.scalafiddle.io/integration.js'></script>
</body>
</html>
